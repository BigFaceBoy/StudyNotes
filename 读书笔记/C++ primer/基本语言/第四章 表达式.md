# 四、表达式
## 4.1 什么是表达式？
## 4.2 算法操作符
## 4.3 等于、关系和逻辑操作符
## 4.4 赋值操作符
## 4.5 递增和递减操作符
    1、后置形式
        i++; 
        在使用 i 的当前值之后，将i递增1
    2、前置形式
        ++i;
        当前值先被递增1，然后再使用它的值。
## 4.6 复数操作符
## 4.7 条件操作符
     expr1 ? expr2 : expr3;
## 4.8 sizeof操作符
    siseof 操作符的作用是返回一个对象或类型名的字节长度，它有以下三种形式：
        sizeof (type name );
        sizeof ( object );
        sizeof object;
    当 sizeof 操作符应用在数组上时,它返回整个数组的字节长度,而不是第一个元素的长度,也不是 ia 包含的元素的个数.
    eg:
        int i_array[3] = {1, 2, 3};
        int *pi = i_array;
        double d_array[3] = {1.0, 2.0, 3.0};
        double *pd = d_array;
        printf("%d %d \n",sizeof(i_array), sizeof(pi));
        printf("%d %d \n",sizeof(d_array), sizeof(pd));
    output:
        12  4
        24  4
    
    sizeof 操作符在编译时刻计算,因此被看作是常量表达式.
## 4.9 new 和 delete
    系统为每个程序都提供了一个在程序执行时可用的内存池,这个可用内存池被称为程序的空闲存储区 free store 或堆 heap,运行时刻的内存分配被称为动态内存分配.
    动态内存分配由 new 表达式应用在一个类型指示符上完成，类型指示符可以是内置类型或用户定义类型，new 表达式返回指向新分配的对象的指针。
## 4.10 逗号操作符
## 4.11 位操作符
## 4.12 bitset 操作符
## 4.13 优先级
## 4.14 类型转换
    1、隐式类型转换
    int val = 3.14 + 3;
    C++并不是把两个不同类型的值加在一起，而是提供了一组算术转换以便在执行算术运算前，将两个操作数转换成共同的类型，转换规则是：小类型总是被提升成大类型，以防止精度损失。本例中，在执行加法前，整数 3 被提升为 double 型，这些转换由编译器自动完成。
    加法以及结果都是 double 型，结果值为 6.14，下一步是把结果赋给 val，如果赋值操作符的左右两边的类型不同，那么，有可能的话，右边操作数会被转换成左边的类型。在本例中 val 的类型是 int，double 向 int 的转换自动按截取而不是舍入进行，小数部分被直接地抛弃。
    隐式类型转换主要发生在以下场景：
     1.1、混合类型的算法表达式中
        该情况下，最宽的数据类型成为目标转换类型。
        eg: int val = 3.14 + 3;
     1.2、用一种类型的表达式赋值给另一种类型的对象
        在这种情况下，目标转换类型是被赋值对象的类型。
        eg: int *pi = 0; //文字常量 0 的类型是 int,它被转换成 int*型的指针,表示空地址
     1.3、把一个表达式传递给一个函数调用，表达式的类型与形式参数的类型不相同
        在这种情况下，目标转换类型是形式参数的类型
     1.4、从一个函数返回一个表达式，表达式的类型与返回类型不相同 
        在这种情况下，目标转换类型是函数的返回类型 
    2、显示类型转换
    显式转换也被称为强制类型转换(cast),包括下列命名的强制类型转换操作符static_cast、dynamic_cast、const_cast 和 reinterpret_cast。
     2.1 把 void*型的指针赋值给任意显式类型时，需要强制类型转换
     2.2 希望改变通常的标准转换
     2.3 避免出现多种转换可能的歧义情况
