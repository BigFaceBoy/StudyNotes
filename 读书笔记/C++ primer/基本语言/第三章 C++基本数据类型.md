# 三、C++基本数据类型
## 3.1 文字常量
    当一个数值,例如1,出现在程序中时,它被称为文字常量. 称之为文字,是因为我们只能以它的值的形式指代它;称之为常量,是因为它的值不能被改变.
    文字常量是不可寻址的.
## 3.2 变量
    变量为我们提供了一个有名字的内存存储区,可以通过程序对其进行读、写和处理, C++中的每个符号变量都与一个特定的数据类型相关联, 这个类型决定了相关内存的大小、布局、能够存储在该内存区的值的范围以及可以应用其上的操作集.

    变量和文字常量都有存储区,并且有相关的类型,区别在于变量是可寻址的(addressable). 对于每一个变量,都有两个值与其相关联:
    1、右值, 即数据值, 存储在某个内存地址中, 文字常量和变量都可被用作右值.
    2、左值, 即地址值, 存储数据值的那块内存地址, 文字常量不能被用作左值.
### 3.2.1 变量的定义
    如果一个变量是在全局域(global scope)内定义的, 那么系统会保证给它提供初始值0.
    如果变量是在局部域(local scope)内定义的, 或是通过 new 表达式动态分配的, 则系统不会向它提供初始值0, 这些对象被称为是未初始化的(uninitialized), 未初始化的对象不是没有值,而是它的值是未定义的(undefined). (与它相关联的内存区中含有一个随机的位串,可能是以前使用的结果.) 
## 3.3 指针类型

## 3.4 字符串类型
### 3.4.1 C风格字符串
### 3.4.2 字符串类型

## 3.5 const限定修饰符
    const 把一个对象转换成一个常量。在程序中，任何企图改变这个这个值的操作都将导致编译错误。
    1、常量在定义后就不能修改，所以常量必须初始化。
    2、任何 “试图将一个非 const 对象的指针指向一个常量对象” 的动作都将引起编译错误。
        eg: 
            const int MAX = 1024;
            int *ptr = &MAX;  //invalid conversion from 'const int*' to 'int*'
    这并不意味着我们不能间接地指向一个 const 对象 只意味着必须声明一个指向常量的指针来间接的指向 const 对象。

    3、const 对象的地址只能赋给指向 const 对象的指针，但是指向 const 对象的指针可以被赋以一个非 const 对象的地址。
        eg:
            const int *p_MAX = 0;
            
            int  faceNum = 5;
            p_MAX = &faceNum;  //ok
        但是这样后，虽然 faceNum 不是常量，但试图通过 p_MAX 修改它的值，仍会导致编译错误。
    4、指向 const 的指针常被用作函数的形式参数，它作为一个约定来保证被传递给函数的实际对象在函数中不会被修改。

## 3.6 引用类型
    引用 reference 有时候又称为别名 alias, 它可以用作对象的另一个名字.通过引用我们可以间接地操纵对象,使用方式类似于指针,但是不需要指针的语法.在实际的程序中,引用主要被用作函数的形式参数——通常将类对象传递给一个函数.

    1、引用类型由类型标识符和一个取地址操作符来定义,引用必须被初始化.
    eg:
       int val = 1024;
       int &ref_val = val;
    定义指针引用：
       int val = 1024;
       int &ref_val = &val;  //error, ref_val是 int 类型

       int *pi = &val;
       int *&ref_pi = pi;  //ok, ref_pi 是一个指向指针的引用
    2、一旦引用已经定义 它就不能再指向其他的对象(这是它为什么必须要被初始化的原因).
    3、引用的所有操作实际上都被应用在它所指的对象身上,包括取地址操作符.

## 3.13 volatile
    volatile 修饰符的主要目的是提示编译器,该对象的值可能在编译器未监测到的情况下被改变,因此编译器不能武断地对引用这些对象的代码作优化处理.
    ??? 多线程使用
## 3.14 pair

## 3.15 类类型