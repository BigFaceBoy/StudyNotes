# 一、 类定义
    类定义包含两部分 —— 类头：由关键字class及其后面的类名构成。类体：由一对花括号包围起来，类定义后面必须接一个分号或一列声明。
        如: 
            class Screen { /* ... */ };
            class Screen { /* ... */ } myScreen, yourScreen;
## 1.1 数据成员 
    class StackScreen {
        int topStack;
        void (*handler)(); // 函数的指针
        vector<Screen> stack; // 类的 vector
    };
    类也可以有静态static 数据成员，静态数据成员有特殊的属性。除了静态 static 数据成员外，数据成员不能在类体中被显式地初始化。类的数据成员通过类的构造函数进行初始化。(我在实际项目中看到很多数据成员在类体显示初始化的情况，是否有什么编译选项可以防止这种情况的编译报错？)。
    class First {
        int memi = 0; // 错误
        double memd = 0.0; // 错误
    };
## 1.2 成员函数
    一个成员函数只能重载自己类的其他成员函数，一个类的成员函数与在其他类或名字空间中声明的函数无关，因此，也不能重载它们。
## 1.3 成员访问
    private：
    public：
    protected：对派生类就像public成员一样，对其他类像private一样。
## 1.4 友元
    友元 friend 机制允许一个类授权其他的函数访问它的非公有成员。
## 1.5 类声明和类定义
    一旦到了类体的结尾，即结束右括号，我们就说一个类被定义了一次。定义一个类，则该类的所有成员都是已知的，类的大小是已知的。
    class Screen{
        int x;
        int y;
        ...
    }; // 类定义

    声明一个类后，只能以有限的方式使用。没有定义类，则我们就不能定义这类类型的对象；但是可以声明指向该类类型的指针和引用。允许指针和引用是因为它们都有固定的大小，这与它们指向的对象的大小无关。
    只有已经看到了一个类的定义，我们才能把一个数据成员声明成该类的对象，在程序文本中还没有看到该类定义的地方，数据成员只能是该类类型的指针或引用。只有当一个类的类体完整时，才能被视为已经定义。所以，一个类不能有自身类型的数据成员。
    class Screen; // 类声明
# 二、类对象
    类的定义不会引起存储区分配。只有当定义一个类的对象时，系统才会分配存储区。
    一个对象可以被同一类类型的另一个对象初始化或赋值，缺省情况下，拷贝一个类对象与拷贝它的全部数据成员等价。
    缺省情况下，当一个类对象被指定为函数实参或函数返回值时，它就被按值传递。
# 三、类成员函数
## 3.1 inline成员函数
    如果函数的定义在类体内提供，则这些函数被称为“在类定义中定义的内联 inline 函数”。这些函数被自动作为 inline 函数处理。
    由于内联函数必须在调用它的每个文本文件中被定义，所以没有在类体中定义的内联成员函数必须被放在类定义出现的头文件中。即，应该放在头文件 Screen.h 中 且跟在类 Screen 的定义后面。
    **Screen.h**
    class Screen{
        inline void get();
    };
    Screen::get(){
        ...
    }
## 3.2 访问类成员
    1、成员函数的定义可以引用任何一个类成员，无论该成员是私有的还是公有的，都不会破坏类访问限制。
    2、成员函数可以直接访问它所属的类的成员，而无需使用点或箭头成员访问操作符。 
## 3.3 特殊的成员函数
    有一组特殊的成员函数可以管理类对象并处理诸如初始化、赋值、内存管理、类型转换以及析构等活动，这些函数通常由编译器隐式调用
    初始化成员函数被称为构造函数(constructor)。每次定义一个类对象或由 new 表达式分配一个类对象时都会调用构造函数。
    还有析构函数、赋值操作符等。
## 3.4 const和volatile成员函数
    通过把成员函数声明为 const 以表明它们不修改类对象。一个 const 类对象只能调用被声明为 const 的成员函数。当然，构造函数和析构函数除外。即使构造函数和析构函数不是 const 成员函数，const类对象也可以调用它们。当构造函数执行结束，类对象已经被初始化时，类对象的常量性就被建立起来了；析构函数一被调用，常量性就消失。所以一个 const 类对象，从构造完成时刻到析构开始时刻，这段时间内被认为是 const。
    把一个成员函数声明为 const 并不能阻止所有修改的动作。如果该类含有指针，那么在 const 成员函数中就能修改指针所指的对象，只要不修改指针所指地址就行。
## 3.5 mutable数据成员
    为了允许修改一个类的数据成员,即使它是一个 const 对象的数据成员。我们可以把该数据成员声明为 mutable 易变的。mutable 数据成员永远不会是 const 成员，即使它是一个 const 对象的数据成员。
# 四、隐含的this指针