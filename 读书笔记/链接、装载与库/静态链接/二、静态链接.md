samplecode
////////////////////////////////////////
/** a.c **/
extern int shared;

int main(){
    int a = 100;
    swap(&a , &shared);
}
/////////////////////////////////////////
/** b.c **/
int shared;

void swap(int* a,int* b){
    *a ^= *b ^= *a ^= *b;
}
/////////////////////////////////////////

    对于链接器来说，链接过程就是将几个输入目标文件加工合并成一个输出文件。对于上面的例子来说，输入是 a.o 和 b.o,输出是可执行文件 "ab"。那么可执行文件 "ab"的代码段和数据段是由 a.o 和 b.o 中代码段和数据段合并而成。
    链接过程主要分为两步：一、空间与地址分配；二、符号解析与重定位
# 一、空间与地址分配
## 1.1 相似段合并
    链接器采用的合并方式是相似段合并，比如将所有输入文件的 ".text"段合并到输出文件的 ".text"段。".bss"段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间。所有链接器在合并".bss"段时，会分配虚拟地址空间。
    “链接器为目标文件分配地址和空间”这句话中的“地址和空间”包括：
    一：可执行文件中的空间
    二：装载后的虚拟地址中的虚拟地址空间。
    对于".text"和".data"来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于".bss"来说，分配空间只局限于虚拟地址空间的分配。

    在链接前，目标文件中的所有段的VMA(Virtual Memory Address)都是0，因为虚拟空间还没有分配。等到链接之后，可执行文件 "ab" 的各个段都被分配了相应的虚拟地址。
## 1.2 符号地址确定
    在合并相似段后，链接器开始计算各个符号的虚拟地址。因为各个符号在段内的相对位置是固定的，所以这时候链接器只需要给每个符号加上对应的偏移量即可。
# 二、符号解析与重定位
## 2.1 重定位
    以 samplecode 为例。a.c 使用了 b.c 中的符号 swap 和 shared 。当编译a.c 时，编译器并不知道 swap 和 shared 的地址，因为它们定义在其他目标文件中，于是编译器使用一些特殊地址作为 swap 和 shared 的地址，如 0x0000 0000 或 0xFFFF FFFF,把真正的地址计算的工作留给链接器。
    由于链接器在完成地址和空间分配后就可以确定所有符号的虚拟地址，那么链接器就可以根据符号的地址对每个需要重定位的指令进行修正。
## 2.2 重定位表
    那么链接器是怎么知道哪些指令需要被修正？如何修正？
    在ELF文件中有一个重定位表，用于保存这些与重定位相关的信息。
## 2.3 符号解析
    重定位的过程伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，当链接器需要对某个符号进行重定位时，它就要确定这个符号的目标地址。
## 2.4 指令修正

# 三 COMMON块机制
    当不同目标文件需要的COMMON块空间大小不一致时，以最大的为准。
    COMMON类型的链接规则是针对符号都是弱符号的情况。
    如果链接过程中有弱符号大小大于强符号，那么链接器会报如下警告：
    ld: warning: alignment 4 of symbol 'global' in a.o is smaller than 8 in b.o

    GCC的 "-fno-common" 允许我们把所有未初始化的全局变量不以COMMON块的形式处理，或者使用 "__attributr__((nocommon))" 扩展。
    一旦一个未初始化的全局变量不是以COMMON块的形式存在，那么它就相当于一个强符号。
# 四 C++相关问题
## 4.1 重复代码消除
    C++编译器在很多时候会产生重复的代码，如模板、外部内联函数和虚函数表都可能在不同的编译单元生成相同的代码。

## 4.2 全局构造和析构
    C++的全局对象构造函数在 main 之前被执行，全局对象的析构函数在 main 之后被执行。
    ELF文件定义了两种特殊的段：
    .init   该段保存的是可执行指令，当一个程序开始运行时，在 main 函数被调用之前，Glibc 的初始化部分安排执行这个段的代码。
    .fini   该段保存进程终止代码指令。当一个程序的 main 函数正常退出时，Glibc 会执行这个段中的代码。
    如果一个函数放到 .init 段，在 main 函数执行前系统就会执行它；如果一个函数放到 .fini 段，在函数返回后该函数会被执行。C++的全局构造和析构就是利用这个特性去实现的。
    
